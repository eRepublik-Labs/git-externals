#!/bin/bash

# GitExternals
# Version: 2025.10.1
# Author: Alexandru Geana <alex.geana@erepubliklabs.com>
#
# This script is used to clone or update git repositories defined in a .gitexternals file.
# The .gitexternals file should be in the root of the repository and have the following format:
# [external "name"]
# path = path/to/clone/repository
# url =
# branch = master
# script = script_to_run_after_cloning_or_updating.sh
# ignore_extensions = *.meta,*.asset  # Optional: comma-separated list of patterns to ignore during deletion
# lfs = true/false  # Optional: enable LFS support (default: false)
#
# Auto-update can be disabled by:
# 1. Setting environment variable: export GITEXTERNALS_NO_UPDATE=1
# 2. Creating .gitexternals.conf with: auto_update = false
# 3. Using --no-update flag when running the script

# Default update URL - change this to your own repository
DEFAULT_UPDATE_URL="https://raw.githubusercontent.com/eRepublik-Labs/git-externals/master/init"

# Function to display text in bold
bold_text() {
    local text="$1"
    printf "\e[1m%s\e[0m\n" "$text"
}

# Functions to display colored text
red_text() {
    local text="$1"
    printf "\e[31m%s\e[0m\n" "$text"
}

green_text() {
    local text="$1"
    printf "\e[32m%s\e[0m\n" "$text"
}

yellow_text() {
    local text="$1"
    printf "\e[33m%s\e[0m\n" "$text"
}

blue_text() {
    local text="$1"
    printf "\e[34m%s\e[0m\n" "$text"
}

magenta_text() {
    local text="$1"
    printf "\e[35m%s\e[0m\n" "$text"
}

cyan_text() {
    local text="$1"
    printf "\e[36m%s\e[0m\n" "$text"
}

# Function to compare version strings (returns 0/true if $1 > $2)
version_gt() {
    local v1="$1" v2="$2"
    local IFS=.
    local i v1_parts=($v1) v2_parts=($v2)

    for ((i=0; i<${#v1_parts[@]}; i++)); do
        local n1="${v1_parts[i]:-0}"
        local n2="${v2_parts[i]:-0}"
        if ((n1 > n2)); then return 0; fi
        if ((n1 < n2)); then return 1; fi
    done
    return 1
}

# Function to extract version from script
extract_version() {
    local file="$1"
    grep "^# Version:" "$file" | sed -E 's/^# Version: (.*)/\1/'
}

# Function to check if auto-update is disabled
is_auto_update_disabled() {
    # Check environment variable
    if [ "${GITEXTERNALS_NO_UPDATE:-0}" = "1" ]; then
        yellow_text "‚è∏Ô∏è  Auto-update disabled via environment variable"
        return 0
    fi
    
    # Check config file
    if [ -f ".gitexternals.conf" ]; then
        local auto_update_setting
        auto_update_setting=$(grep -E "^[[:space:]]*auto_update[[:space:]]*=" ".gitexternals.conf" 2>/dev/null | sed -E 's/^[[:space:]]*auto_update[[:space:]]*=[[:space:]]*(.*)[[:space:]]*$/\1/')
        if [ "$auto_update_setting" = "false" ] || [ "$auto_update_setting" = "0" ] || [ "$auto_update_setting" = "no" ]; then
            yellow_text "‚è∏Ô∏è  Auto-update disabled via .gitexternals.conf"
            return 0
        fi
    fi
    
    # Check for global flag
    if [ "${SKIP_AUTO_UPDATE:-0}" = "1" ]; then
        yellow_text "‚è∏Ô∏è  Auto-update disabled for this run"
        return 0
    fi
    
    return 1
}

# Function to install git hook
install_hook() {
    bold_text "Installing Git post-merge hook..."
    
    # Get the git hooks directory
    local hooks_dir
    hooks_dir=$(git rev-parse --git-path hooks)
    
    if [ ! -d "$hooks_dir" ]; then
        red_text "Error: Git hooks directory not found. Are you in a git repository?"
        return 1
    fi
    
    local hook_file="$hooks_dir/post-merge"
    local script_path
    script_path="$(cd "$(dirname "$0")" && pwd)/$(basename "$0")"
    
    # Check if hook already exists
    if [ -f "$hook_file" ]; then
        # Check if our hook is already installed
        if grep -q "$script_path" "$hook_file"; then
            yellow_text "Hook already installed."
            return 0
        else
            # Backup existing hook
            yellow_text "Existing hook found. Creating backup."
            cp "$hook_file" "$hook_file.bak"
        fi
    fi
    
    # Create the hook
    cat > "$hook_file" << EOF
#!/bin/sh
#
# Git Externals post-merge hook
# Automatically updates externals after git pull/merge

# Run the git-externals script (with --no-update to avoid auto-updating the script itself in hooks)
"$script_path" --no-update

# Exit with the script's exit code
exit \$?
EOF
    
    # Make the hook executable
    chmod +x "$hook_file"
    
    green_text "‚úÖ Post-merge hook installed successfully!"
    green_text "Externals will now update automatically after git pull/merge operations."
    return 0
}

# Function to update the script itself
self_update() {
    # Check if auto-update is disabled
    if is_auto_update_disabled; then
        return 0
    fi
    
    bold_text "‚ÑπÔ∏è Checking for updates..."
    
    # Check for curl
    if ! command -v curl &> /dev/null; then
        red_text "Error: curl is required for self-update but not installed."
        return 1
    fi
    
    # Use default update URL
    local update_url="$DEFAULT_UPDATE_URL"
    
    bold_text "Using update URL: $update_url"
    
    # Create temp file
    local tmp_file
    tmp_file=$(mktemp)
    
    # Download latest version
    if ! curl --connect-timeout 10 -s -L "$update_url" -o "$tmp_file"; then
        red_text "‚õîÔ∏è Failed to download update from $update_url"
        rm -f "$tmp_file"
        return 1
    fi
    
    # Check if download was successful and file is not empty
    if [ ! -s "$tmp_file" ]; then
        red_text "‚ö† Downloaded file is empty. This might be because:"
        red_text "1. The URL is incorrect"
        red_text "2. Network issues"
        rm -f "$tmp_file"
        return 1
    fi
    
    # Extract versions
    local current_version
    current_version=$(extract_version "$0")
    local new_version
    new_version=$(extract_version "$tmp_file")
    
    bold_text "- Current version: $current_version"
    bold_text "- Latest version: $new_version"
    
    # Compare versions
    if version_gt "$new_version" "$current_version"; then
        green_text "New version available! Updating..."
        
        # Make the new script executable
        chmod +x "$tmp_file"
        
        # Replace current script with new version
        if mv -f "$tmp_file" "$0"; then
            green_text "‚úÖ Update successful! Now running version $new_version"
            
            # Re-execute the updated script with the same arguments
            bold_text "üîÑ Restarting with updated version..."
            exec "$0" "$@"
            # exec replaces the current process, no code after this will run
        else
            red_text "‚ùå Failed to replace current script. Check permissions."
            return 1
        fi
    else
        yellow_text "Already running the latest version."
        rm -f "$tmp_file"
        return 0
    fi
}

# Function to clone or update a repository
clone_or_update_repo() {
    local path="$1"
    local url="$2"
    local branch="$3"
    local script="$4"
    local name="$5"
    local lfs="$6"
    local ignore_extensions="$7"  # Add ignore_extensions parameter

    echo ""
    
    # Use the external name for the cache directory
    local git_dir=$(git rev-parse --git-dir)
    local repo_cache_dir="$git_dir/externals/$name"
    
    # Ensure the externals directory exists
    mkdir -p "$git_dir/externals"
    
    if [ -d "$repo_cache_dir" ]; then
        bold_text "üîµ Repository cache exists. Updating repository."
        cd "$repo_cache_dir"
        
        # Check if the remote is accessible
        if ! git fetch origin "$branch"; then
            red_text "‚ö†Ô∏è Failed to fetch from remote. Check network or repository access."
            cd - > /dev/null
            return 1
        fi
        
        # Check if the branch exists in the remote
        if ! git ls-remote --heads origin "$branch" | grep -q "$branch"; then
            red_text "‚ö†Ô∏è Branch '$branch' does not exist in the remote repository."
            yellow_text "Available branches:"
            git ls-remote --heads origin | sed 's/.*refs\/heads\///'
            cd - > /dev/null
            return 1
        fi
        git reset --hard FETCH_HEAD
        git clean -fdx
        # Pull LFS objects if repo is LFS-enabled
        if [ "$lfs" = "true" ]; then
            bold_text "üì¶ Pulling LFS objects..."
            if command -v git-lfs &> /dev/null; then
                git lfs pull
            else
                yellow_text "‚ö†Ô∏è git-lfs not installed, skipping LFS pull"
            fi
        fi
        cd - > /dev/null
    else
        bold_text "‚¨áÔ∏è Cloning git repository $url to cache with depth 1 and blob filtering"
        git clone --branch "$branch" --depth 1 --filter=blob:none "$url" "$repo_cache_dir"
        # Initialize LFS and pull objects if repo is LFS-enabled
        if [ "$lfs" = "true" ]; then
            bold_text "üì¶ Initializing LFS and pulling objects..."
            if command -v git-lfs &> /dev/null; then
                cd "$repo_cache_dir"
                git lfs install
                git lfs pull
                cd - > /dev/null
            else
                yellow_text "‚ö†Ô∏è git-lfs not installed, skipping LFS initialization"
            fi
        fi
    fi
    
    # Ensure the target directory exists
    mkdir -p "$(dirname "$path")"
    
    # Check if the target directory already exists
    if [ -d "$path" ]; then
        bold_text "üóëÔ∏è Removing existing files in $path (preserving ignored extensions)"
        
        # Build the find command with exclusions
        local find_cmd="find \"$path\" -mindepth 1 -not -name \".gitignore\""
        
        # Add exclusions for ignored extensions
        if [ -n "$ignore_extensions" ]; then
            yellow_text "üìå Preserving files with extensions: $ignore_extensions"
            # Convert comma-separated list to array
            IFS=',' read -ra IGNORED_EXTS <<< "$ignore_extensions"
            for ext in "${IGNORED_EXTS[@]}"; do
                # Trim whitespace
                ext=$(echo "$ext" | xargs)
                if [ -n "$ext" ]; then
                    find_cmd="$find_cmd -not -name \"$ext\""
                fi
            done
        fi
        
        # Execute the find command and delete
        find_cmd="$find_cmd -exec rm -rf {} \; 2>/dev/null || true"
        eval "$find_cmd"
    else
        bold_text "üìÅ Creating target directory $path"
        mkdir -p "$path"
    fi
    
    # Copy files from cache to target path (excluding .git directory)
    bold_text "üìã Copying files from cache to $path"
    git -C "$repo_cache_dir" archive HEAD | tar -x -C "$path"
    
    # Create a .gitexternal file to track where this came from
    cat > "$path/.gitexternal" << EOF
# This directory contains files from an external repository
# DO NOT MODIFY THESE FILES DIRECTLY
# 
# External: $name
# Source: $url
# Branch: $branch
# Last updated: $(date)
EOF
    
    # Add ignored extensions info if present
    if [ -n "$ignore_extensions" ]; then
        echo "# Preserved extensions: $ignore_extensions" >> "$path/.gitexternal"
    fi
    
    if [ -n "$script" ]; then
        script_path="$(dirname "$0")/$script"
        echo "script_path: $script_path"
        # Check if the script exists
        if [ -f "$script_path" ]; then
            # Check if the script is executable, if not, make it executable
            if [ ! -x "$script_path" ]; then
                yellow_text "‚ö†Ô∏è Script $script_path is not executable. Changing permissions."
                chmod +x "$script_path"
            fi
            green_text "üü¢ Running script $script for $path"
            "$script_path"
        else
            red_text "üî¥ Script $script not found at $script_path"
        fi
    else
        green_text "üü¢ No script defined for $path"
    fi
}

# Function to parse a line
parse_line() {
    local line="$1"
    local key="$2"
    local value
    
    if [[ "$line" =~ ^[[:space:]]*$key[[:space:]]*=[[:space:]]*(.*)[[:space:]]*$ ]]; then
        value="${BASH_REMATCH[1]}"
    else
        red_text "‚ùå Failed to parse $key from line: $line"
    fi
    
    echo "$value"
}

# Function to process a single external
process_external() {
    local name="$1"
    local path="$2"
    local url="$3"
    local branch="$4"
    local script="$5"
    local lfs="$6"
    local ignore_extensions="$7"
    
    cyan_text "- Processing external: $name"
    cyan_text "- Path: $path"
    cyan_text "- URL: $url"
    cyan_text "- Branch: $branch"
    cyan_text "- Script: $script"
    cyan_text "- LFS: $lfs"
    cyan_text "- Ignore Extensions: $ignore_extensions"
    
    if [ -n "$name" ]; then
        clone_or_update_repo "$path" "$url" "$branch" "$script" "$name" "$lfs" "$ignore_extensions"
    fi
}

# Function to parse the .gitexternals file
parse_gitexternals() {
    local file=".gitexternals"
    local name=""
    local path=""
    local url=""
    local branch=""
    local script=""
    local lfs="false"
    local ignore_extensions=""
    
    yellow_text "Parsing .gitexternals file..."
    
    while IFS= read -r line || [ -n "$line" ]; do
        # Skip empty lines or lines with only whitespace
        if [[ -z "${line// }" ]]; then
            continue
        fi
        
        if [[ "$line" =~ ^\[external[[:space:]]\"(.*)\"\][[:space:]]*$ ]]; then
            if [ -n "$name" ]; then
                process_external "$name" "$path" "$url" "$branch" "$script" "$lfs" "$ignore_extensions"
            fi
            
            name="${BASH_REMATCH[1]}"
            path=""
            url=""
            branch="master"
            script=""
            lfs="false"
            ignore_extensions=""  # Reset ignore_extensions for new external
        else
            key=$(echo "$line" | sed -E 's/^[[:space:]]*([^[:space:]=]+)[[:space:]]*=.*$/\1/')
            
            case "$key" in
                path)
                    path=$(parse_line "$line" "path")
                    ;;
                url)
                    url=$(parse_line "$line" "url")
                    ;;
                branch)
                    branch=$(parse_line "$line" "branch")
                    ;;
                script)
                    script=$(parse_line "$line" "script")
                    ;;
                lfs)
                    lfs=$(parse_line "$line" "lfs")
                    ;;
                ignore_extensions)
                    ignore_extensions=$(parse_line "$line" "ignore_extensions")
                    ;;
                *)
                    red_text "Unknown key: $key"
                    ;;
            esac
        fi
    done < "$file"
    
    # Process the last external if any
    if [ -n "$name" ]; then
        process_external "$name" "$path" "$url" "$branch" "$script" "$lfs" "$ignore_extensions"
    fi
    
    bold_text "Finished parsing .gitexternals file."
}

# Function to show help
show_help() {
    bold_text "GitExternals - A tool to manage git externals"
    echo ""
    echo "Usage: $(basename "$0") [options] [command]"
    echo ""
    echo "Commands:"
    echo "  (no command)     Parse .gitexternals file and clone/update repositories"
    echo "  update           Manually check and update this script to the latest version"
    echo "  install-hook     Install git post-merge hook for automatic updates"
    echo "  help             Show this help message"
    echo ""
    echo "Options:"
    echo "  --no-update      Skip auto-update check for this run"
    echo ""
    echo ".gitexternals file format:"
    echo "  [external \"name\"]"
    echo "  path = path/to/clone/repository"
    echo "  url = git@github.com:user/repo.git"
    echo "  branch = master"
    echo "  script = script_to_run.sh           # Optional"
    echo "  lfs = true                           # Optional (default: false)"
    echo "  ignore_extensions = *.meta,*.asset   # Optional: patterns to preserve"
    echo ""
    echo "Disabling auto-update:"
    echo "  1. Set environment variable: export GITEXTERNALS_NO_UPDATE=1"
    echo "  2. Create .gitexternals.conf with: auto_update = false"
    echo "  3. Use --no-update flag when running the script"
    echo ""
}

# Function to create sample config file
create_sample_config() {
    local config_file=".gitexternals.conf"
    
    if [ -f "$config_file" ]; then
        yellow_text "Config file already exists: $config_file"
        return 1
    fi
    
    cat > "$config_file" << 'EOF'
# GitExternals Configuration File
# This file controls the behavior of the git-externals script

# Enable or disable automatic updates of the script
# Values: true/false, yes/no, 1/0
# Default: true
auto_update = true

# Update URL (optional)
# Override the default update URL for the script
# update_url = https://example.com/path/to/script

# Verbose output (optional)
# Values: true/false, yes/no, 1/0
# Default: false
# verbose = false
EOF
    
    green_text "‚úÖ Created sample configuration file: $config_file"
    cyan_text "Edit this file to customize GitExternals behavior."
    return 0
}

cd "$(dirname "$0")"

# Parse command line arguments
SKIP_AUTO_UPDATE=0
COMMAND=""

while [[ $# -gt 0 ]]; do
    case "$1" in
        --no-update)
            SKIP_AUTO_UPDATE=1
            shift
            ;;
        update)
            COMMAND="update"
            shift
            ;;
        install-hook)
            COMMAND="install-hook"
            shift
            ;;
        create-config)
            COMMAND="create-config"
            shift
            ;;
        help|--help|-h)
            COMMAND="help"
            shift
            ;;
        *)
            yellow_text "Unknown option: $1"
            show_help
            exit 1
            ;;
    esac
done

# Execute command
case "$COMMAND" in
    update)
        # Force update even if disabled
        GITEXTERNALS_NO_UPDATE=0
        SKIP_AUTO_UPDATE=0
        self_update
        exit $?
        ;;
    install-hook)
        install_hook
        exit $?
        ;;
    create-config)
        create_sample_config
        exit $?
        ;;
    help)
        show_help
        exit 0
        ;;
    *)
        # Default action: run auto-update (if not disabled) then parse gitexternals
        self_update
        parse_gitexternals
        ;;
esac
